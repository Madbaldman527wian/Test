local Players      = game:GetService("Players")
local RunService   = game:GetService("RunService")
local Workspace    = game:GetService("Workspace")

local speaker      = Players.LocalPlayer
local character    = speaker.Character or speaker.CharacterAdded:Wait()
local rootPart     = character:WaitForChild("HumanoidRootPart")

---- parâmetros
local BASE_RADIUS  = 0
local MAX_RADIUS   = 150
local RADIUS_STEP  = 10        -- incremento de cada variação
local UPDATE_RATE  = 1 / 20   -- 30 Hz

---- estado
local RADIUS       = BASE_RADIUS
local radiusDir    = 1         -- 1 = crescendo, -1 = diminuindo
local tracked      = {}        -- [part] = {bp = BodyPosition, dir = Vector3}
local currentTarget

---- utilidades --------------------------------------------------------------

local function isPlayerPart(part)
    local m = part.Parent
    while m do
        if Players:GetPlayerFromCharacter(m) then
            return true
        end
        m = m.Parent
    end
end

local function randomUnitVector()
    local u, v = math.random(), math.random()
    local theta = 2 * math.pi * u
    local phi   = math.acos(2 * v - 1)
    return Vector3.new(
        math.sin(phi) * math.cos(theta),
        math.sin(phi) * math.sin(theta),
        math.cos(phi)
    )
end

local function chooseRandomTarget()
    local pool = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= speaker and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            pool[#pool + 1] = p
        end
    end
    currentTarget = #pool > 0 and pool[math.random(#pool)] or nil
end

---- rastreamento de partes ---------------------------------------------------

local function track(part)
    if tracked[part] or part.Anchored or isPlayerPart(part) or part:FindFirstChildWhichIsA("Motor6D", true) then
        return
    end

    local bp = Instance.new("BodyPosition")
    bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bp.D, bp.P  = 1000, 50000
    bp.Parent   = part

    tracked[part] = {
        bp  = bp,
        dir = randomUnitVector()
    }

    -- posição inicial
    bp.Position = rootPart.Position + tracked[part].dir * RADIUS
    part.AssemblyAngularVelocity = Vector3.new(
        math.random(-50, 50),
        math.random(-50, 50),
        math.random(-50, 50)
    )

    part.Destroying:Connect(function()
        tracked[part] = nil
    end)
end

-- inicial: rastreia tudo o que já existe
for _, p in ipairs(Workspace:GetDescendants()) do
    if p:IsA("BasePart") and not p.Anchored then
        track(p)
    end
end
-- novos objetos
Workspace.DescendantAdded:Connect(function(p)
    if p:IsA("BasePart") and not p.Anchored then
        track(p)
    end
end)

---- loops --------------------------------------------------------------------

-- alvo aleatório
task.spawn(function()
    while true do
        chooseRandomTarget()
        task.wait(1)
    end
end)

-- atualização principal
local tAcc = 0
RunService.Heartbeat:Connect(function(dt)
    tAcc += dt
    if tAcc < UPDATE_RATE then return end
    tAcc -= UPDATE_RATE

    -- ajusta raio
    RADIUS += radiusDir * RADIUS_STEP
    if RADIUS >= MAX_RADIUS or RADIUS <= BASE_RADIUS then
        radiusDir *= -1
        RADIUS = math.clamp(RADIUS, BASE_RADIUS, MAX_RADIUS)
    end

    -- posição do centro
    local center = rootPart.Position
    if currentTarget and currentTarget.Character then
        local trg = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        if trg then center = trg.Position end
    end

    -- atualiza partes rastreadas
    for part, data in pairs(tracked) do
        if part.Parent then
            data.bp.Position = center + data.dir * RADIUS
        else
            tracked[part] = nil
        end
    end
end)
